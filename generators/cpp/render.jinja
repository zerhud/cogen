<% macro type(obj) -%>
<= obj.name =><% if obj.sub[0] is defined %><<% for st in obj.sub %><= type(st) =><= ", " if not loop.last =><% endfor %>><% endif %>
<%- endmacro %>

<%- macro fparam(params) -%>
<% for param in params %><= type(param.par_type) => <= param.name =><= ", " if not loop.last =><% endfor %>
<%- endmacro %>

<%- macro gen_namespace_name(module, cdata) -%>
<% for n in cdata.namespaces %><=n=>::<% endfor -%>
<= module.namespace =>
<%- endmacro %>

<%- macro decl_depricated(obj) -%>
<%- if obj.depricated %>[[depricated<% if obj.depricated.message != '' %>("<= obj.depricated.message =>")<% endif %>]] <% endif %>
<%- endmacro %>

<%- macro decl_meta_params(mparams) -%>
<%- if mparams.docs -%>///  <= mparams.docs =>
<% endif -%>
<%- endmacro %>

<%- macro function_header(obj) -%>
<= decl_meta_params(obj) -=>
<= decl_depricated(obj) -=>
<= "static " if obj.static =><=- type(obj.ret_type) => <= obj.name =>(<= fparam(obj.params) =>)<= " const" if obj.mutable == False =>
<%- endmacro %>

<%- macro includes(incs) -%>
<%- for inc in incs %>
#include <= '"' if inc.local else '<' =><= inc.n =><= '"' if inc.local else '>' =>
<%- endfor -%>
<%- endmacro -%>

<%- macro ptr(obj, cdata) -%><=obj.name=><=cdata.ptr_postfix=><% endmacro -%>


<%- macro interface(obj) -%>
class <= decl_depricated(obj) =><= obj.name => {
public:
	virtual ~<= obj.name =>() noexcept =default;
	<% for fnc in obj.members %>
	virtual <= function_header(fnc) => =0 ;
	<% endfor %>
};
<% endmacro -%>

<% macro enum(obj, module, cdata) -%>
<% set nn = gen_namespace_name(module, cdata) %>
std::string <= nn =>::to_string(<=nn=>::<=obj.name=> v)
{
	<%- for i in  obj.members %>
	if(v==<=obj.name=>::<=i.name=>) return "<=i.output=>";
	<%-endfor%>
	assert(false);
	return "";
}
std::wstring <= nn =>::to_wstring(<=nn=>::<=obj.name=> v)
{
	<%- for i in  obj.members %>
	if(v==<=obj.name=>::<=i.name=>) return L"<=i.output=>";
	<%-endfor%>
	assert(false);
	return L"<=obj.output=>";
}
<% endmacro -%>
