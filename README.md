<span style="display:block; text-align:center; font-weight:bold;">cogen</span>
<p>the following articles was copied from the original host, from fossil wiki. some links may be broken</p>

<p><b>The Cogen</b> - a  code generation framework. Can be used for generate code by template (jinja2 used for now) from some dsl (an iterface description language only implemented for now). The user can write own templates, configuration files and dsls. the generator will link dsl's nodes, find imports and apply some common functions (MapTo, MapFrom and other). the project (and the web site) hosted by <a href="https://fossil-scm.org" target="_blank">fossil</a>.</p>

<p>code generation in cogen by steps:<ul><li>get input in some user-friendly and simple dsl</li><li>get settings</li><li>generate boilerplate data for template</li><li>use a template engine for get the result (jinja2 was choice)</li></ul></p>

<p><b>after installation</b> you can find<ul><li><b>/bin/cogen</b> this program</li><li><b>/bin/cogenwr.py</b> script wrapper around cogen with template engine, use it for now (python3 and python jinja2 module must to be available)</li><li><b>/etc/cogen/examples</b> ix3 input example</li><li><b>/etc/cogen/generators</b> configurations</li><li><b>/etc/cogen/lib</b> template library</li></ul></p>

<p><b>cpp python bridge</b>. From the box for now we can only generate (for now) cpp python bridge, using pybind11. as input ix3 will be used (the only dsl for now). there is an ix3 example. to get the compiled example use command <u>cogenwr.py -iix3=ix3_example -I /etc/cogen/examples/incs -gcpp_py -odir</u>. after it <b>dir</b> will be created in current directory and generations result will be placed to there. options, used here<ul><li><b>-iix3</b>: the <b>-i or --input</b> option: the dsl file. format like dsl_name=dsl_file.</li><li><b>-I</b> include directories for dsl</li><li><b>-g</b> the generator, or configuration</li><li><b>-o</b> output directory</li></ul></p>

<h1>General Concepts</h1>
<p>Why we use codegeneration? <ul><li>we want to use simple and comfort language for <b>domain</b></li><li>we don't want write boilerplate code and want to generate it</li><li>we want to generate client and server, for example rest api client in java script and server in c++</li><li>and others cases...</li></ul>so we need few DSLs (domain specefic language), and language for write code template and some configurator for manage it. The cogen has the following structure: <img src="http://cpphttpx.org/repos/cogen/uv/cogen_arch.svg" style="display:block" />here we have:<UL><LI><b>DSL</b> is an dsl file or dsl input</LI><LI><b>DSL Processor</b> compose data from dsl. the data contains everything for generate single file or few files in result. it contains also needed imports, links between data items and so on..</LI><LI>here we can just produce the data and use it. but the cogen contains also the <b>jinja2</b> processor, the <b>templater</b> in diagram</LI><LI><b>Template</b> is a file with data for template</LI><LI>The <b>Result file</b> single or many result files</LI><LI>and the <b>configurator</b>. it manage all the process, so we can pass some arguments to cogen executable file for configure the process.</LI></UL></p>
<p>after we introduced general concepts, let's see few example of use, sorted by hardness level</p>

<h1 style="display:inline">Level 1:</h1> <b>just generate json for custom generator</b>
<p>you can just generate data as json for use any generator you want. the example of use such data lives <a href="file?name=cogen/cogenwr.py&ci=tip">here</a>. for example let's generate just a struct in c++ using <b>ix3</b> dsl. just execute such command <b>echo "module mod v1.0: record foo{ +string f1; -string f2; }" | cogen -m json -iix3=- -Gpart.dec.tmpl=tmpl.jinja -Gpart.dec.file=dec.hpp</b>. please note: all next documentation will assume what the user are using some shell, like bash. let's see what we have here<UL><LI>echo call for generate data<UL><LI><a href="wiki?name=ix3">here is</a> a wiki page about ix3. just few moments:</LI><LI>first of all we declare a module named <b>mod</b> and version <b>1.0</b></LI><LI>inside the module we declare a <b>record</b> or structure</LI><LI>and we declare <b>f1</b> as required string field</LI><LI>and <b>f2</b> as optional string field</LI></UL></LI><LI>pipe for forward data to std::cin in cogen</LI><LI>cogen call for produce data for codegeneration<UL><LI><b>-m json</b> we want to produce json data instead of creation real files</LI><LI><b>-iix3=-</b> we want to read ix3 from std::cin. <b>-i</b> option describe input in dsl, after we have dsl name and afer = sign the source of the dsl</LI><LI>the <b>-G</b> or <b>gopt</b> option adds generation option. first we have <b>part.dec.tmpl</b> option. the part option declare parts, or resulting files. we have only one part: <b>dec</b>. and here declared one option of this part - <b>tmpl</b>: the template file of this part. for now it just a file, the file name will be forwarded to output (but we need to create this file, leave it empty, we will fill it later).</LI><LI>the next option is <b>file</b>. the option declare the output name of the resulting file of this part.</LI></UL></LI></UL>in the result we have a json with everything data needed to generate a file, using, for example, jinja generator. the output is too big to place it here.</p>

<h1 style="display:inline">Level 2:</h1> <b>generate two files with real template</b>
<p>here we will create generator file (what include all options <b>-G</b> you see above), template file, and get in result a directory containing the generated files.</p>
<p>let's write a template file. edit the file we just created - <b>tmpl.jinja</b>: <tt style="background:rgb(220,220,220);display:inline-block;"><pre>jinja test template
<%- for mod in data.data.ix3 -%>
<%- for ver in mod.vers -%>
<%- for item in ver.content -%>
name: <= item.name =>
<% endfor -%>
<%- endfor -%>
<%- endfor -%></pre></tt>this is a jinja template. you can find documentation on the internet, it also has some extra features (it's a realization of jinja written on cpp, cppjinja), such as before or after block sign you can write a signed integer for shift up or down the next block, for example  <b>+3%&gt;</b> will shift the next block on 3 position (add 3 tabs).</p>
<p>ok, it was a template. lets try to use it. <b>echo "module mod v1.0: record foo{ +string f1; -string f2; }" | cogen -m <u>dir -o dir</u> -iix3=- -Gpart.dec.tmpl=tmpl.jinja -Gpart.dec.file=dec.hpp</b>. the changed part is underlined. the <b>dir</b> mode tells the cogen that we want to create directory and render data with template, instead of <i>json</i> mode, which only produce a data for a future generation. the <b>-o dir</b> or it can to be <b>--outdir</b> tells the name of the resulting directory, now it's a just <i>dir</i>. we can see the result by typing <b>cat dir/dec.hpp</b>. as you can see, the name of file was taken from <b>part.dec.file</b> generation option.</p>
<p>all <b>-G</b> options often the same, and if you want to generate many output files, it will be very long command line, if we want write all options in it. so, there is a feature that allows to separate the options from command line. for do that we need to create a generator file. the cogen products some generated files, lets see, for example, a generation file for c++ declarations. it just generate c++ declarations for all types we declare in ix3. <a href="file?name=cogen/generators/cpp_decl.info&ci=tip">here it is</a>. the format is boost.info (you can find out the documentation in boost.property_tree). let's see what new<UL><LI><b>defaults</b> here we can write default options for all parts</LI><LI><b>naming</b> name style, using in input (in dsl) can be changed. for each part separately.</LI><LI><b>inc_part</b> tells the cogen what part headers depends on part dec. so, in template, we can include the part (we don't know the name or part's result, as we can see later).</LI><LI><b>filter</b> we can filter input and <b>sel</b> or select only few entity from it.</LI><LI>and in last, cmake part, we just forward some options to the template generator. note, all options written in the generator file (or in -G option) will be available in jinja generation. (the <b>-G</b> option overrides options in generator file)</LI></UL>the <b>cpp_decl.info</b> file distributed with the cogen and cogen can find it and the template files it peeks. so now the command becomes <b>echo "module mod v1.0: record foo{ +string f1; -string f2; }" | cogen -m <u>dir -o dir</u> -iix3=- <u>-gcpp_decl</u></b>. the <b>.info</b> suffix will be placed inside.</p>
<p>let's see what happened:<tt style="background:rgb(220,220,220);display:inline-block;"><pre>$ ls dir         
CMakeLists.txt  dec.hpp  declarations.hpp  module.cpp  module.hpp</pre></tt>in the result we have few files, generated by template.</p>
<p>there is also some features that are not present in cpp_decl generator. the cogen contains (at the moment the article was written, not all generators are ready) a bridge generator <a href="file?name=cogen/generators/py_cpp.info&ci=tip">python->cpp</a> and <a href="file?name=cogen/generators/cpp_py.info&ci=tip">cpp->python</a>. the python->cpp generator allows to write script using python and execute it from c++ code, and cpp->python generator allows to write c++ modules for python. let's see some features, using in the generator<UL><LI>result file name declared as <b>file "${mod}_${mod_a}_${mod_i}/declarations.hpp"</b>. it allows us to generate few files, file per module version, as in this example. for example, if we have modules mod1 and mod2, versions in each module are 1.0 and 1.1, we will have four files: mod1_1_0, mod1_1_1, mod2_1_0 and mod2_1_1</LI><LI><b>self_inc</b> tells the cogen include or not one part result to another. for example, if mod2 depends on mod1, and we generate file by name template as ${mod} it will generate two files, with name mod1 and mod2, but we want to mod2 knows in which file mod1 lives. in inc_self is true the information will be provided to mod2 (mod1 will knows nothing about mod2 'cause mod1 doesn't depends on mod2)</LI><LI>you can find two <b>naming</b> options. it allows us to write a bridge from one name style to other. if we more then one naming option, the name field in result data will be an array and contains as many items, as naming options was.</LI><LI>other options will be forwarded to the template.</LI><LI>as we noted above there is few dsls in input. one of them is ix3, we pass it in echo command. other is build dsl, it reads options from info file. for example in cmake we see libraries names are formed with pattern instead of just name, it's a same pattern as file name. it includes also parts instead of real files, the part will be replaced with real file names it generates.</LI></UL></p>

<h1 style="display:inline">Level 3:</h1> <b>add some types in c++, use few dsl</b>
<p>as you can note, we use string type in example above. it will be translated to std::string in c++ and other types in other languages. but how cogen knows it? there is a <a href="file?name=cogen/lib/standard_types.info&ci=tip">file with standard types</a>. it provide all information we need to generate standard types for each using languages. if we write string in input dsl, the type field in the result data will contains few types, as it described in the standard_types file. the string for c++ will be replaced with std::pmr::string, the file string will be included and mark system:true will be provided. it the standard_types file will contains other language, the types will contains also the language and information for it.</p>

<h1 style="display:inline">Level 4:</h1> <b>use other features</b>
<p>documentation in progressssssss</p>
