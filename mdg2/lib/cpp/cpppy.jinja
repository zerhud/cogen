<% import "cpp/render.jinja" as render -%>
// this file is autogenerated, don't edit this
// this file contains realization of helpers function

#include <cassert>
#include <memory_resource>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
<= render.includes(cdata.includes) =>

namespace py = pybind11;

<% for module in cdata.data.ix3 -%>
<% for mod_ver in module.vers %>

<%- macro module_name(mod) %><= mod|name(1) =>_<= mod.v.major =><= mod.v.minor =><% endmacro %>
<%- macro obj_ref(obj, mod, mod_ver) %><= render.gen_namespace_name(mod, mod_ver) =>::<= obj|name =><% endmacro %>
<%- macro ptr_ref(obj, mod, mod_ver) %><= render.gen_namespace_name(mod, mod_ver) =>::<= render.ptr(obj) =><% endmacro %>
<%- macro def_class(obj,mod,cdata) %>
	<% for ctor in obj.ctors %>m.def("<=obj|apply_prefix("create",1)=>", &<=render.gen_namespace_name(mod,cdata)=>::<=obj|apply_prefix("create")=> );<%endfor%>
	pybind11::class_<<=obj_ref(obj,mod,cdata)=>, <=ptr_ref(obj,mod,cdata)=>>(m, "<= obj|name(1) =><= '_base' if obj.rinvert =>")
		<%- for mem in obj.funcs %>
		.def("<=mem|name(1)=>", &<=obj_ref(obj,mod,cdata)=>::<=mem|name=>)<% endfor %>
		;
<% endmacro -%>
<% macro def_invert_class(obj, mod, cdata, ref) %>
	pybind11::class_<<=obj_ref(obj,mod,cdata)=>, <=ref=>, <=ptr_ref(obj,mod,cdata)=>>(m, "<= obj|name(1) =>")
		<= '.def(py::init())' =>
		<%- for mem in obj.funcs %>
		.def("<=mem|name(1)=>", &<=obj_ref(obj,mod,cdata)=>::<=mem|name=>)<% endfor %>
		;
<% endmacro -%>
<%- macro def_struct(obj,mod,cdata) %>
	pybind11::class_<<= obj_ref(obj,mod,cdata) =>, <=ptr_ref(obj,mod,cdata)=>>(m, "<= obj|name(1) =>")
		.def(py::init())
		<%- for f in obj.fields %>
		.def_readwrite("<=f|name(1)=>", &<=obj_ref(obj,mod,cdata)=>::<=f|name=>)<% endfor %>
		;
<% endmacro -%>
<%- macro def_enum(obj,mod,cdata) %>
	pybind11::enum_<<= obj_ref(obj,mod,cdata) =>>(m, "<= obj|name(1) =>")
		<%- for mem in obj.members %>
		.value("<= mem|name(1) =>", <= obj_ref(obj,mod,cdata) =>::<= mem|name =>)<% endfor %>
		;
<% endmacro %>

<% for obj in mod_ver.content if obj.type == "interface" and obj.rinvert -%>
class <=module|name=>_<=obj|name=>
	: public <= obj_ref(obj,module,mod_ver) =>
	, public std::enable_shared_from_this<<=module|name=>_<=obj|name=>> {
public:
	<=module|name=>_<=obj|name=>() noexcept =default ;
	<%- for mem in obj.funcs %>
	<=render.function_header(mem)=> override {
		 PYBIND11_OVERRIDE_PURE(<=render.type(mem.return)=>, <= obj_ref(obj,module,mod_ver) =>, <=mem|name(1)=>
		 <%for p in mem.params%>, <=p|name=><%endfor%>
		 );
	}<% endfor %>
};
<% endfor %>

PYBIND11_MODULE(<= module|name =>, m) {
	<% for obj in mod_ver.content -%>
	<%- if obj.type == "function" -%>m.def("<= obj|name(1) =>", &<= obj_ref(obj, module, mod_ver) =>, "<= obj.docs =>");
	<% endif %>
	<%- if obj.type == "interface" and not obj.rinvert -%><= def_class(obj,module,mod_ver) =><%- endif %>
	<%- if obj.type == "interface" and obj.rinvert -%><= def_invert_class(obj,module,mod_ver,module|name+'_'+obj|name) =><%- endif %>
	<%- if obj.type == "record" -%><= def_struct(obj,module,mod_ver) =><%- endif %>
	<%- if obj.type == "enum" -%><= def_enum(obj,module,mod_ver) =><%- endif %>
	<%- endfor %>
}

<% endfor %>
<% endfor %>

