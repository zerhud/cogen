<% import "cpp/render.jinja" as render -%>
// this file is autogenerated, don't edit this
// this file contains declarations of modules
#pragma once
#include <memory>
<= render.includes(cdata.includes) =>

<% for module in cdata.data.ix3 -%>
<% for mod_ver in module.vers %>

<= render.decl_meta_params(module) =>
namespace <= render.gen_namespace_name(module, mod_ver) => {
	<%- for obj in mod_ver.content %>
	<% if obj.type == "function" -%><= render.function_header(obj) =>;
	<%- elif obj.type == "enum" -%>
	<= render.decl_meta_params(obj) =>
	enum class <= render.decl_depricated(obj) =><= obj.name =>
	{
		<% for mem in obj.members -%><= mem.name =><=- ", " if not loop.last =><%- endfor %>
	};
	<% if obj.auto_io -%>
	std::string to_string(<= obj.name => v);
	std::wstring to_wstring(<= obj.name => v);
	template<typename S> std::enable_if_t<std::is_same_v<char,typename S::char_type>,S&> operator << (S& out, <= obj.name => o) { return out << to_string(o); }
	template<typename S> std::enable_if_t<std::is_same_v<wchar_t,typename S::char_type>,S&> operator << (S& out, <= obj.name => o) { return out << to_wstring(o); }
	<%- endif -%>
	<%- elif obj.type == "interface" -%>
	<= render.decl_meta_params(obj) =>
	class <= render.decl_depricated(obj) =><= obj.name => ;
	using <= render.ptr(obj,cdata) => = std::shared_ptr<<= obj.name =>>;
	<% for cnst in obj.constructors %>std::unique_ptr<<= obj.name =>> <= render.constructor_name(cnst,obj,cdata) =>(<=render.fparam(cnst.params)=>);<% endfor %>
	<%- elif obj.type == "record" -%>
	<= render.decl_meta_params(obj) =>
	struct <= render.decl_depricated(obj) =><= obj.name => ;
	using <= render.ptr(obj,cdata) => = std::shared_ptr<<= obj.name =>>;
	<%- else -%> #error unknown derective <= obj.name => <%- endif -%>
	<%- endfor %>
} // namespace <= render.gen_namespace_name(module, mod_ver) =>
<% endfor %>
<% endfor %>

