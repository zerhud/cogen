<% import "cpp/render.jinja" as render -%>
// this file is autogenerated, don't edit this
// this file contains declarations of modules
#pragma once
 render.includes(cdata.includes) 

<% for module in cdata.data.ix3 -%>
<% for mod_ver in module.content %>

namespace <= module.name =>_<= mod_ver.value =>;

<= render.decl_meta_params(module) =>
namespace <= render.gen_namespace_name(module, cdata) => {
	<%- for obj in module.content %>
	<% if obj.type == "function" -%><= render.function_header(obj) =>;
	<%- elif obj.type == "enumeration" -%>
	<= render.decl_meta_params(obj) =>
	enum class <= render.decl_depricated(obj) =><= obj.name =>
	{
		<% for mem in obj.members -%> <= mem.name =>  <=- ", " if not loop.last => <%- endfor %>
	};
	<% if obj.gen_io -%>
	std::string to_string(<= obj.name => v);
	std::wstring to_wstring(<= obj.name => v);
	template<typename S> std::enable_if_t<std::is_same_v<char,typename S::char_type>,S&> operator << (S& out, <= obj.name => o) { out << to_string(o); return out; }
	template<typename S> std::enable_if_t<std::is_same_v<wchar_t,typename S::char_type>,S&> operator << (S& out, <= obj.name => o) { out << to_wstring(o); return out; }
	<%- endif -%>
	<%- elif obj.type == "interface" -%>
	<= render.decl_meta_params(obj) =>
	class <= render.decl_depricated(obj) =><= obj.name => ;
	using <= render.ptr(obj,cdata) => = std::shared_ptr<<= obj.name =>>;
	<% for cnst in obj.constructors %>std::unique_ptr<<= obj.name =>> <= render.constructor_name(cnst,obj,cdata) =>(<=render.fparam(cnst.params)=>);<% endfor %>
	<%- elif obj.type == "record" -%>
	<= render.decl_meta_params(obj) =>
	struct <= render.decl_depricated(obj) =><= obj.name => ;
	<%- else -%> #error unknown derective <= obj.name => <%- endif -%>
	<%- endfor %>
} // namespace <= render.gen_namespace_name(module, cdata) =>
<% endfor %>
<% endfor %>

